//SPDX-License-Identifier: Apache
pragma solidity ^0.8.0;

import "./Celestial.sol";
import "./Galaxy.sol";
import "./Items.sol";

struct FactoryPair {
    ItemKind kind;
    uint8 count;
}

/**
 * A contract inheriting from this handles all celestials that convert take some input items
 * to create some output items.
 */
abstract contract FactoryCelestial is Celestial {

    // The Items contract.
    Items ItemsContract;

    // The kind of item generated by this kind of celestial.
    ItemKind public itemKind;

    // The input items necessary to use this factory along with their quantities.
    FactoryPair[] public inputs;

    // The output items necessary to use this factory along with their quantities.
    FactoryPair[] public outputs;

    // Data storage for all celestial of the kind handled by this contract.
    mapping (uint => CelestialData) dataMap;

    constructor(
        Items _ItemsContract,
        CelestialKind _kind)
            Celestial(_kind) {
        ItemsContract = _ItemsContract;
    }

    function unsafeData(uint celestialID) view internal override returns (CelestialData storage) {
        return dataMap[celestialID];
    }

    function addedExternally(CelestialMapEntry memory mapEntry) external override {
        // TODO ACCESS CONTROL
        // NOTE: We do not check for existence here, meaning the galaxy owner can use
        // `Galaxy#addCelestial` to override existing celestials.
        dataMap[getCelestialID(mapEntry.x, mapEntry.y)] = CelestialData(address(0), block.number);
    }

    // Return the block number at which the celestial was last updated.
    function lastUpdate(uint celestialID) view external returns (uint) {
        return data(celestialID).lastUpdate;
    }

    function produce(address player, uint celestialID) external {
        CelestialData storage data = data(celestialID);
        require(data.owner == player, "Celestial is not owned by player");
        // TODO handle reentrancy attack
        for (uint i = 0; i < inputs.length; i++) {
            uint balance = ItemsContract.balanceOf(player, uint(inputs[i].kind));
            require(balance >= inputs[i].count, "insufficient balance");
        }
        for (uint i = 0; i < inputs.length; i++)
            ItemsContract.burn(player, inputs[i].kind, inputs[i].count);
        for (uint i = 0; i < outputs.length; i++)
            ItemsContract.mint(player, outputs[i].kind, outputs[i].count, bytes(""));
    }

    // TODO this is a crutch for testing to be removed - also unsafe
    function setOwner(address player, uint celestialID) external {
        CelestialData storage data = data(celestialID);
        data.owner = player;
    }
}
